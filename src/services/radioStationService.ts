import { MusicCacheService, AudioTrack, MusicLibraryEntry } from './musicCacheService';
import allImageUrl from '../assets/all.jpg';
import { genreSimilarity } from './id3Service';


export interface TrackScore {
  track: MusicLibraryEntry;
  score: number;
}
export interface RadioStation {
  id: string;
  name: string;
  description: string | undefined;
  criteria: RadioStationCriteria[];
  createdAt: Date;
  updatedAt: Date;
  lastPlayed?: Date | null;
  isAutoGenerated?: boolean;
  isTemporary?: boolean;
  isCustom?: boolean | undefined;
  isAllMusic?: boolean | undefined;
  imagePath?: string | undefined;
  favoritedAt?: Date | null | undefined;
}

export type RadioStationAttribute = 'artist' | 'album' | 'genre' | 'mood' | 'decade';

export interface RadioStationCriteria {
  attribute: RadioStationAttribute;
  value: string;
  weight: number; // 0-1 scale
  requirement: boolean;
}

export class RadioStationService {
  constructor() {
  }

/**
   * Create a new radio station
   */
  public async createStation(station: Omit<RadioStation, 'id' | 'createdAt' | 'updatedAt'>): Promise<RadioStation> {
    const description = station.description !== undefined ? station.description : undefined;
    const isAutoGenerated = station.isAutoGenerated !== undefined ? station.isAutoGenerated : false;
    const isTemporary = station.isTemporary !== undefined ? station.isTemporary : false;
    let idHash = station.isCustom ? (new Date()).toString() : station.name;
    const newStation: RadioStation = {
      id: this.generateId(idHash),
      name: station.name,
      description,
      criteria: station.criteria,
      createdAt: new Date(),
      updatedAt: new Date(),
      isAutoGenerated,
      isTemporary,
      isAllMusic: station?.isAllMusic,
      imagePath: station?.imagePath,
      isCustom: station?.isCustom,
      favoritedAt: null
    };

    await this.storeStation(newStation);
    return newStation;
  }

/**
   * Update an existing radio station
   */
  public async updateStation(station: RadioStation, updates: Partial<Omit<RadioStation, 'id' | 'createdAt'>>): Promise<RadioStation> {

    const description = updates.description !== undefined ? updates.description : station.description;
    const isAutoGenerated = updates.isAutoGenerated !== undefined ? updates.isAutoGenerated : station.isAutoGenerated || false;
    const isTemporary = updates.isTemporary !== undefined ? updates.isTemporary : station.isTemporary || false;
    const updatedStation: RadioStation = {
      ...station,
      name: updates.name || station.name,
      description,
      criteria: updates.criteria || station.criteria,
      isAutoGenerated,
      isTemporary,
      updatedAt: new Date(),
      lastPlayed: updates.lastPlayed || station.lastPlayed || null,
      imagePath: updates.imagePath || station.imagePath,
      isCustom: updates.isCustom || station.isCustom,
      favoritedAt: updates.favoritedAt !== undefined ? updates.favoritedAt : station.favoritedAt,
    };

    await this.storeStation(updatedStation);
    return updatedStation;
  }

  /**
   * Delete a radio station
   */
  public async deleteStation(id: string): Promise<void> {
    const db = (MusicCacheService.getInstance() as any).db;
    if (!db) {
      throw new Error('Database not initialized');
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['radioStations'], 'readwrite');
      const store = transaction.objectStore('radioStations');
      const request = store.delete(id);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Get all radio stations
   */
  public async getAllStations(): Promise<RadioStation[]> {
    const db = (MusicCacheService.getInstance() as any).db;
    if (!db) {
      throw new Error('Database not initialized');
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['radioStations'], 'readonly');
      const store = transaction.objectStore('radioStations');
      const request = store.getAll();

      request.onsuccess = () => {
        resolve(request.result || []);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  }

  /**
   * Get the all-music generic station
   */
  public async getDefaultStation(): Promise<RadioStation> {
    let station = (await this.getAllStations())
      .find(station => station.isAllMusic === true);
    if (station) return station;

    return await radioStationService.createStation({
      name: "All Music",
      description: "I'm feeling lucky",
      criteria: [],
      isAutoGenerated: true,
      isAllMusic: true,
      imagePath: allImageUrl
    });
  }

  /**
   * Get a radio station by ID
   */
  public async getStationById(id: string): Promise<RadioStation | null> {
    const db = (MusicCacheService.getInstance() as any).db;
    if (!db) {
      throw new Error('Database not initialized');
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['radioStations'], 'readonly');
      const store = transaction.objectStore('radioStations');
      const request = store.get(id);

      request.onsuccess = () => {
        resolve(request.result || null);
      };

      request.onerror = () => {
        reject(request.error);
      };
    });
  }

  /**
    * Score tracks for a radio station based on weighted criteria
    * Returns only tracks with scores greater than zero, sorted
    */
  public async scoreTracksForStation(
    station: RadioStation,
    playbackHistory: AudioTrack[]
  ): Promise<TrackScore[]> {
    const allTracks = await MusicCacheService.getInstance().getAllCachedEntries();

    if (allTracks.length === 0) {
      return [];
    }

    if (station.isTemporary && station.criteria.length === 0) {
      return [];
    }

    let recent = [...playbackHistory].reverse().slice(0, 20);

    const scoredTracks: TrackScore[] = [];

    for (const track of allTracks) {
      let index = recent.findIndex(t => t.id === track.id);
      let penalty = 0;
      if (index >= 0) {
        // last 5 tracks are effectively never repeated, then chances decrease
        penalty = Math.min(1, Math.max(0, 1 - (index - 5) / 20));
      }
      const score = this.calculateTrackScore(track, station.criteria) * (1 - penalty);
      if (score > 0) {
        scoredTracks.push({ track: track, score });
      }
    }

    scoredTracks.sort((a, b) => b.score - a.score);

    return scoredTracks;
  }

  /**
   * Select tracks for a radio station based on weighted criteria
   */
  public async selectNextTrackForStation(
    station: RadioStation,
    playbackHistory: AudioTrack[]
  ): Promise<TrackScore | null> {
    const scoredTracks = await this.scoreTracksForStation(station, playbackHistory);

    if (scoredTracks.length === 0) return null;

    const totalScore = scoredTracks.reduce((sum, item) => sum + item.score, 0);
    if (totalScore <= 0) return null;

    let randomValue = Math.random() * totalScore;
    for (let i = 0; i < scoredTracks.length; i++) {
      const track = scoredTracks[i];
      if (!track) continue;
      randomValue -= track.score;
      if (randomValue <= 0) {
        return track || null;
      }
    }

    return scoredTracks[0] ?? null;
  }

  /**
   * Calculate a weighted score for how well a track matches the station criteria
   */
  private calculateTrackScore(track: MusicLibraryEntry, criteria: RadioStationCriteria[]): number {
    let totalWeight = 0;
    let weightedSum = 0;
    let requiredWeight: number | null = null;

    // if there is no criteria, everything matches
    if (criteria.length === 0) return 1;

    // Normalize weights so they sum to 1
    const criterionWeights = this.normalizeWeights(criteria);

    for (const criterion of criteria) {
      const attributeWeight = criterionWeights.get(criterion.attribute) || 0;
      if (attributeWeight === 0) continue;

      const matchScore = this.calculateAttributeMatch(track, criterion);
      weightedSum += matchScore * attributeWeight;
      if (criterion.requirement) {
        requiredWeight = (requiredWeight ?? 1) * weightedSum;
      } else {
        totalWeight += attributeWeight;
      }
    }
    if (requiredWeight !== null) {
      totalWeight *= requiredWeight;
    }

    // Return the weighted sum (already normalized)
    return weightedSum;
  }

  /**
   * Normalize weights so they sum to 1
   */
  private normalizeWeights(criteria: RadioStationCriteria[]): Map<string, number> {
    const weightMap = new Map<string, number>();
    let totalWeight = 0;

    // Sum all weights
    for (const criterion of criteria) {
      weightMap.set(criterion.attribute, criterion.weight);
      totalWeight += criterion.weight;
    }

    // Normalize if there are any criteria
    if (totalWeight > 0) {
      for (const [attr, weight] of weightMap.entries()) {
        weightMap.set(attr, weight / totalWeight);
      }
    }

    return weightMap;
  }

  /**
   * Calculate how well a track matches a specific criterion
   */
  private calculateAttributeMatch(track: MusicLibraryEntry, criterion: RadioStationCriteria): number {
    switch (criterion.attribute) {
      case 'artist':
        return this.matchString(track.artist, criterion.value);
      case 'album':
        return this.matchString(track.album, criterion.value);
      case 'genre':
        return genreSimilarity(track.genre, criterion.value);
      case 'mood':
        return this.matchString(track.mood, criterion.value);
      case 'decade':
        // Extract decade from year
        const trackDecade = Math.floor(track.year / 10) * 10;
        const criterionDecade = parseInt(criterion.value);
        if (trackDecade === criterionDecade) { return 1; }
        let diff = Math.min(Math.abs(criterionDecade - track.year), Math.abs(criterionDecade + 10 - track.year));
        return Math.max(1 - diff * .2, 0);
      default:
        return 0;
    }
  }

  /**
   * Calculate string match score (0-1)
   */
  private matchString(trackValue: string, criterionValue: string): number {
    if (!trackValue || !criterionValue) return 0;

    // Exact match gets full score
    if (trackValue.toLowerCase() === criterionValue.toLowerCase()) {
      return 1;
    }

    // Partial match gets partial score based on similarity
    const trackLower = trackValue.toLowerCase();
    const criterionLower = criterionValue.toLowerCase();

    if (trackLower.includes(criterionLower)) {
      // If criterion is contained in track value, score based on length ratio
      return Math.min(0.8, criterionLower.length / trackLower.length);
    }

    if (criterionLower.includes(trackLower)) {
      // If track value is contained in criterion, give some credit
      return Math.min(0.5, trackLower.length / criterionLower.length);
    }

    return 0;
  }

  /**
   * Store a radio station in the database
   */
  private async storeStation(station: RadioStation): Promise<void> {
    const db = (MusicCacheService.getInstance() as any).db;
    if (!db) {
      throw new Error('Database not initialized');
    }

    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['radioStations'], 'readwrite');
      const store = transaction.objectStore('radioStations');
      const request = store.put(station);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  /**
   * Generate a unique ID for a station
   */
  private generateId(name: string): string {
    // Simple hash function for generating IDs from names
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      const char = name.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return `station_${hash.toString()}`;
  }

  /**
   * Create a temporary radio station based on an tracks
   */
  public async createStationFromTracks(title: string, tracks: MusicLibraryEntry[], weightAdjustments?: Partial<Record<RadioStationAttribute, number>>, isTemporary?: boolean): Promise<RadioStation> {
    const tempStation = await radioStationService.createStation({
      name: title,
      description: title,
      criteria: [],
      isAutoGenerated: true,
      isTemporary: isTemporary ?? false
    });

    await radioStationService.updateStationFromTracks(tempStation, tracks, weightAdjustments);
    return tempStation;
  }

  /**
   * Create a temporary radio station based on an artist
   */
  public async createArtistStation(artist: string, tracks: MusicLibraryEntry[]): Promise<RadioStation> {
    return await this.createStationFromTracks(`Station from ${artist}`, tracks, {
      album: 0,
      decade: 0.5,
    }, true);
  }

  /**
   * Create a temporary radio station based on an album
   */
  public async createAlbumStation(artist: string, album: string, tracks: MusicLibraryEntry[]): Promise<RadioStation> {
    return await this.createStationFromTracks(`${artist} - ${album}`, tracks, {
      artist: 0.5, // it matters, but you picked the album for a reason
      decade: 0.5,
    }, true);
  }

  /**
    * Update a radio station's criteria based on an array of AudioTracks
    * Averages the criteria values from all tracks
    */
  public async updateStationFromTracks(
    station: RadioStation,
    tracks: MusicLibraryEntry[],
    weightAdjustments?: Partial<Record<RadioStationAttribute, number>>
  ): Promise<void> {
    // Calculate average criteria from the tracks
    const averagedCriteria = this.calculateAverageCriteria(tracks, station.criteria);

    // Apply weight adjustments if provided
    if (weightAdjustments && Object.keys(weightAdjustments).length > 0) {
      for (const [attribute, adjustment] of Object.entries(weightAdjustments)) {
        const attr = attribute as RadioStationAttribute;

        // Find all criteria with this attribute and update them
        averagedCriteria.forEach((criterion, index) => {
          if (criterion.attribute === attr && adjustment !== undefined) {
            // Apply the adjustment multiplier to the weight
            criterion.weight *= adjustment;
            // Update in place since we're modifying the array directly
            averagedCriteria[index] = { ...criterion };
          }
        });
      }
    }

    station.updatedAt = new Date();
    // Sort criteria by weight (descending) and take top 5
    const sortedCriteria = [...averagedCriteria]
      .filter(c => c.weight > 0)
      .sort((a, b) => b.weight - a.weight);

    // Take the top 5 criteria or all if less than 5
    station.criteria = sortedCriteria.slice(0, 5);

    if(station.isCustom){
      const albumArtUrl = await this.getAlbumArtForStation(tracks);
      if (albumArtUrl) {
        station.imagePath = albumArtUrl;
      }
    }

    await this.storeStation(station);
  }

  /**
    * Get album art URL for a station based on tracks
    */
  private async getAlbumArtForStation(tracks: MusicLibraryEntry[]): Promise<string | null> {
    // Find the first track with album art
    for (const track of tracks) {
      const musicCache = MusicCacheService.getInstance();
      const albumArtUrl = await musicCache.getAlbumArtUrl(track);
      if (albumArtUrl) {
        return albumArtUrl;
      }
    }
    return null;
  }

  /**
   * Calculate average criteria from an array of tracks
   */
  private calculateAverageCriteria(
    tracks: MusicLibraryEntry[],
    existingCriteria: RadioStationCriteria[]
  ): RadioStationCriteria[] {
    if (tracks.length === 0) {
      return existingCriteria;
    }

    // Collect all attribute values from tracks
    const attributeValues = new Map<string, { values: Set<string>; count: number }>();

    for (const track of tracks) {
      // Extract artist
      if (track.artist) {
        const key = `artist:${track.artist}`;
        if (!attributeValues.has(key)) {
          attributeValues.set(key, { values: new Set(), count: 0 });
        }
        attributeValues.get(key)!.count++;
      }

      // Extract album
      if (track.album) {
        const key = `album:${track.album}`;
        if (!attributeValues.has(key)) {
          attributeValues.set(key, { values: new Set(), count: 0 });
        }
        attributeValues.get(key)!.count++;
      }

      // Extract genres (comma-separated)
      if (track.genre) {
        const genres = track.genre.split(',').map(g => g.trim());
        for (const genre of genres) {
          const key = `genre:${genre}`;
          if (!attributeValues.has(key)) {
            attributeValues.set(key, { values: new Set(), count: 0 });
          }
          attributeValues.get(key)!.count++;
        }
      }

      // Extract mood
      if (track.mood) {
        const key = `mood:${track.mood}`;
        if (!attributeValues.has(key)) {
          attributeValues.set(key, { values: new Set(), count: 0 });
        }
        attributeValues.get(key)!.count++;
      }

      // Extract decade from year
      if (track.year) {
        const decade = Math.floor(track.year / 10) * 10;
        const key = `decade:${decade}`;
        if (!attributeValues.has(key)) {
          attributeValues.set(key, { values: new Set(), count: 0 });
        }
        attributeValues.get(key)!.count++;
      }
    }

    // Calculate average weights for each attribute value
    const averagedCriteria: RadioStationCriteria[] = [];

    for (const [key, data] of attributeValues.entries()) {
      const [attribute, value] = key.split(':') as [string, string];
      const weight = data.count / tracks.length;

      if (weight > 0) {
        averagedCriteria.push({
          attribute: attribute as RadioStationCriteria['attribute'],
          value,
          weight,
          requirement: false,
        });
      }
    }

    return averagedCriteria;
  }
}

// Singleton instance
export const radioStationService = new RadioStationService();