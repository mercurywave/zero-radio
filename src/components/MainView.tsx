import React, { useEffect, useState, useRef } from 'react';
import SearchView from './SearchView';
import { AudioTrack, MusicCacheService, MusicLibraryEntry, SearchResult } from '../services/musicCacheService';
import './MainView.css';
import { RadioStation, radioStationService } from '../services/radioStationService';
import { performSearch } from '../services/searchService';

const cacheService = MusicCacheService.getInstance();

interface MainViewProps {
  onPlayTrack?: (track: AudioTrack) => void;
  onPlayStation?: (station: RadioStation, leadTrack?: MusicLibraryEntry) => void;
  onAlbumSelected?: (album: any) => void;
  onArtistSelected?: (artistName: string) => void;
  onStationSelected?: (stationId: string) => void;
  onCreateNewStation?: () => void;
}

const MainView: React.FC<MainViewProps> = ({ onPlayTrack, onPlayStation, onAlbumSelected, onArtistSelected, onStationSelected, onCreateNewStation }) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<SearchResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);

  // State for suggested stations from the service
  const [suggestedStations, setSuggestedStations] = useState<RadioStation[]>([]);
  const [recentStations, setRecentStations] = useState<RadioStation[]>([]);
  const [isLoadingSuggestions, setIsLoadingSuggestions] = useState(true);

  // Initialize the cache service and fetch suggested stations when component mounts
  useEffect(() => {
    const initAndFetchSuggestions = async () => {
      try {
        await cacheService.initDB();
        let allStations = (await radioStationService.getAllStations())
          .filter(s => s.isAutoGenerated && !s.isAllMusic && !s.isTemporary);
        // Select 5 random stations if available
        let randomStations: RadioStation[] = [];
        if (allStations.length > 0) {
          randomStations = allStations.sort(() => Math.random() - 0.5).slice(0, 20);
        }
        let playAll = await radioStationService.getDefaultStation();
        setSuggestedStations([playAll, ...randomStations]);
        // Get stations with lastPlayed, sort by lastPlayed (newest first), and cap to 20
        const recent = allStations
          .filter(station => station.lastPlayed)
          .sort((a, b) => {
            if (!a.lastPlayed || !b.lastPlayed) return 0;
            return b.lastPlayed.getTime() - a.lastPlayed.getTime();
          })
          .slice(0, 20);
        setRecentStations(recent);
      } catch (error) {
        console.error('Failed to initialize database:', error);
      }
      setIsLoadingSuggestions(false);
    };

    initAndFetchSuggestions();
  }, []);

  // Perform search when query changes
  useEffect(() => {
    if (searchQuery.trim() === '') {
      setSearchResults([]);
      setIsSearching(false);
      return;
    }

    const performSearchWrapper = async () => {
      await performSearch(
        searchQuery,
        setSearchResults,
        setIsSearching
      );
    };

    // Add a small delay to avoid too frequent searches
    const timeoutId = setTimeout(performSearchWrapper, 100);
    return () => clearTimeout(timeoutId);
  }, [searchQuery]);


  return (
    <div className="radio-stations-view">
      <SearchView
        onSearchQueryChange={setSearchQuery}
        searchQuery={searchQuery}
        searchResults={searchResults}
        isSearching={isSearching}
        onPlayTrack={onPlayTrack}
        onPlayStation={onPlayStation}
        onAlbumSelected={onAlbumSelected}
        onArtistSelected={onArtistSelected}
        onStationSelected={onStationSelected}
        onCreateNewStation={onCreateNewStation}
      />

      {searchQuery.trim() === '' && !isLoadingSuggestions && <RenderStationTiles suggestedStations={suggestedStations} recentStations={recentStations} onPlayStation={onPlayStation} onStationSelected={onStationSelected} />}
    </div>
  )
}

// Render radio station tiles when no search query
const RenderStationTiles = ({ suggestedStations, recentStations, onPlayStation, onStationSelected }: { suggestedStations: any[], recentStations: any[], onPlayStation?: ((station: RadioStation, leadTrack?: MusicLibraryEntry) => void) | undefined, onStationSelected?: ((stationId: string) => void) | undefined }) => {
  return (
    <>
      {/* Suggested Stations */}
      <div className="section-title">
        <h3>Suggested Stations</h3>
      </div>
      <ScrollableContainer 
        items={suggestedStations} 
        onPlayStation={onPlayStation} 
        onStationSelected={onStationSelected} 
      />

      {/* Recent Stations */}
      <div className="section-title">
        <h3>Recently Played</h3>
      </div>
      <ScrollableContainer 
        items={recentStations} 
        onPlayStation={onPlayStation} 
        onStationSelected={onStationSelected} 
      />
    </>
  );
};

// Scrollable container component with edge scrolling
const ScrollableContainer: React.FC<{ 
  items: any[], 
  onPlayStation?: ((station: RadioStation, leadTrack?: MusicLibraryEntry) => void) | undefined, 
  onStationSelected?: ((stationId: string) => void) | undefined 
}> = ({ items, onPlayStation, onStationSelected }) => {
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const scrollTimerRef = useRef<any | null>(null);
  const scrollDirectionRef = useRef<'left' | 'right' | null>(null);

  // Handle mouse move for edge scrolling
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!scrollContainerRef.current) return;
    
    // Get the inner grid element that actually scrolls
    const gridElement = scrollContainerRef.current.querySelector('.radio-station-grid-horizontal');
    if (!gridElement) return;
    
    const container = scrollContainerRef.current;
    const rect = container.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const containerWidth = rect.width;
    
    // Define scroll threshold (50px from edges)
    const threshold = 50;
    
    // Stop any existing timer
    if (scrollTimerRef.current) {
      clearTimeout(scrollTimerRef.current);
      scrollTimerRef.current = null;
    }
    
    // Calculate scroll speed based on distance from edge
    let scrollSpeed = 0;
    if (mouseX < threshold && gridElement.scrollLeft > 0) {
      // Scroll left
      const distanceFromEdge = threshold - mouseX;
      scrollSpeed = Math.min(20, distanceFromEdge / 2); // Speed increases as mouse gets closer to edge
      scrollDirectionRef.current = 'left';
      gridElement.scrollLeft -= scrollSpeed;
    } else if (mouseX > containerWidth - threshold && gridElement.scrollLeft < gridElement.scrollWidth - containerWidth) {
      // Scroll right
      const distanceFromEdge = mouseX - (containerWidth - threshold);
      scrollSpeed = Math.min(20, distanceFromEdge / 2); // Speed increases as mouse gets closer to edge
      scrollDirectionRef.current = 'right';
      gridElement.scrollLeft += scrollSpeed;
    } else {
      scrollDirectionRef.current = null;
    }
    
    // Only continue scrolling if we're still near the edge
    if (scrollDirectionRef.current !== null) {
      scrollTimerRef.current = setTimeout(() => {
        if (scrollContainerRef.current && scrollDirectionRef.current) {
          // Recursively call handleMouseMove with the same event to maintain consistent scrolling
          handleMouseMove(e);
        }
      }, 16); // ~60fps
    }
  };

  // Handle mouse leave to reset scrolling
  const handleMouseLeave = () => {
    if (scrollTimerRef.current) {
      clearTimeout(scrollTimerRef.current);
      scrollTimerRef.current = null;
    }
    scrollDirectionRef.current = null;
  };

  return (
    <div 
      className="horizontal-scroll-container"
      ref={scrollContainerRef}
      onMouseMove={handleMouseMove}
      onMouseLeave={handleMouseLeave}
    >
      <div className="radio-station-grid-horizontal">
        {items.map((station) => (
          <div
            key={station.id}
            className="radio-station-card"
            onClick={() => onPlayStation && onPlayStation(station)}
          >
            {station.imagePath && (
              <img src={station.imagePath} alt={station.name} className="station-image" />
            )}
            <div className="station-label">{station.name.toUpperCase()}</div>
            <button
              className="station-detail-arrow"
              onClick={(e) => {
                e.stopPropagation();
                onStationSelected && onStationSelected(station.id);
              }}
              aria-label={`View details for ${station.name}`}
            >
              â†·
            </button>
          </div>
        ))}
      </div>
    </div>
  );
};

export default MainView;